
/* 
 * Copyright (c) 2008-2012, Andy Bierman, All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *

*** Generated by yangdump 2.5-5

    User SIL module
    module MicrowaveModel-Notifications
    revision 2016-08-09
    namespace uri:onf:MicrowaveModel-Notifications
    organization ONF (Open Networking Foundation) Open Transport Working Group - Wireless Transport Project

 */

#include <xmlstring.h>

#include "procdefs.h"
#include "agt.h"
#include "agt_cb.h"
#include "agt_not.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "dlq.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "ses.h"
#include "status.h"
#include "val.h"
#include "val_util.h"
#include "xml_util.h"
#include "u_MicrowaveModel-Notifications.h"
#include "y_MicrowaveModel-Notifications.h"



#include "utils.h"
#include <pthread.h>
#include <time.h>
#include <math.h>
#include <errno.h>


static obj_template_t *ObjectCreationNotification_obj;
static obj_template_t *ObjectDeletionNotification_obj;
static obj_template_t *AttributeValueChangedNotification_obj;
static obj_template_t *ProblemNotification_obj;

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include <net-snmp/agent/agent_trap.h>
#include <net-snmp/agent/snmp_agent.h>
#include <net-snmp/agent/agent_callbacks.h>
#include <net-snmp/agent/snmp_vars.h>

/* put your static variables here */

netsnmp_transport *transport = NULL;
netsnmp_session sess, *session = &sess, *rc = NULL;
static fd_set read_fd_set;
struct timeval         timeout;
uint32 g_attr_counter = 0;
uint32 g_problems_counter = 0;

/********************************************************************
* FUNCTION u_MicrowaveModel_Notifications_ObjectCreationNotification_send
* 
* Send a u_MicrowaveModel_Notifications_ObjectCreationNotification notification
* Called by your code when notification event occurs
* 
********************************************************************/
void u_MicrowaveModel_Notifications_ObjectCreationNotification_send (
    int32 counter,
    const xmlChar *timeStamp,
    const xmlChar *objectIdRef,
    const xmlChar *objectType)
{
    agt_not_msg_t *notif;
    val_value_t *parmval;
    status_t res = NO_ERR;


    if (LOGDEBUG) {
        log_debug("\nGenerating <ObjectCreationNotification> notification");
    }
    
    notif = agt_not_new_notification(ObjectCreationNotification_obj);
    if (notif == NULL) {
        log_error("\nError: malloc failed, cannot send "
        "<ObjectCreationNotification> notification");
        return;
    }
    
    /* add counter to payload */
    parmval = agt_make_int_leaf(
        ObjectCreationNotification_obj,
        y_MicrowaveModel_Notifications_N_counter,
        counter,
        &res);
    if (parmval == NULL) {
        log_error(
            "\nError: make leaf failed (%s), cannot send "
            "<ObjectCreationNotification> notification",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }
    
    /* add timeStamp to payload */
    parmval = agt_make_leaf(
        ObjectCreationNotification_obj,
        y_MicrowaveModel_Notifications_N_timeStamp,
        timeStamp,
        &res);
    if (parmval == NULL) {
        log_error(
            "\nError: make leaf failed (%s), cannot send "
            "<ObjectCreationNotification> notification",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }
    
    /* add objectIdRef to payload */
    parmval = agt_make_leaf(
        ObjectCreationNotification_obj,
        y_MicrowaveModel_Notifications_N_objectIdRef,
        objectIdRef,
        &res);
    if (parmval == NULL) {
        log_error(
            "\nError: make leaf failed (%s), cannot send "
            "<ObjectCreationNotification> notification",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }
    
    /* add objectType to payload */
    parmval = agt_make_leaf(
        ObjectCreationNotification_obj,
        y_MicrowaveModel_Notifications_N_objectType,
        objectType,
        &res);
    if (parmval == NULL) {
        log_error(
            "\nError: make leaf failed (%s), cannot send "
            "<ObjectCreationNotification> notification",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }
    
    agt_not_queue_notification(notif);
    
} /* u_MicrowaveModel_Notifications_ObjectCreationNotification_send */


/********************************************************************
* FUNCTION u_MicrowaveModel_Notifications_ObjectDeletionNotification_send
* 
* Send a u_MicrowaveModel_Notifications_ObjectDeletionNotification notification
* Called by your code when notification event occurs
* 
********************************************************************/
void u_MicrowaveModel_Notifications_ObjectDeletionNotification_send (
    int32 counter,
    const xmlChar *timeStamp,
    const xmlChar *objectIdRef)
{
    agt_not_msg_t *notif;
    val_value_t *parmval;
    status_t res = NO_ERR;


    if (LOGDEBUG) {
        log_debug("\nGenerating <ObjectDeletionNotification> notification");
    }
    
    notif = agt_not_new_notification(ObjectDeletionNotification_obj);
    if (notif == NULL) {
        log_error("\nError: malloc failed, cannot send "
        "<ObjectDeletionNotification> notification");
        return;
    }
    
    /* add counter to payload */
    parmval = agt_make_int_leaf(
        ObjectDeletionNotification_obj,
        y_MicrowaveModel_Notifications_N_counter,
        counter,
        &res);
    if (parmval == NULL) {
        log_error(
            "\nError: make leaf failed (%s), cannot send "
            "<ObjectDeletionNotification> notification",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }
    
    /* add timeStamp to payload */
    parmval = agt_make_leaf(
        ObjectDeletionNotification_obj,
        y_MicrowaveModel_Notifications_N_timeStamp,
        timeStamp,
        &res);
    if (parmval == NULL) {
        log_error(
            "\nError: make leaf failed (%s), cannot send "
            "<ObjectDeletionNotification> notification",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }
    
    /* add objectIdRef to payload */
    parmval = agt_make_leaf(
        ObjectDeletionNotification_obj,
        y_MicrowaveModel_Notifications_N_objectIdRef,
        objectIdRef,
        &res);
    if (parmval == NULL) {
        log_error(
            "\nError: make leaf failed (%s), cannot send "
            "<ObjectDeletionNotification> notification",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }
    
    agt_not_queue_notification(notif);
    
} /* u_MicrowaveModel_Notifications_ObjectDeletionNotification_send */


/********************************************************************
* FUNCTION u_MicrowaveModel_Notifications_AttributeValueChangedNotification_send
* 
* Send a u_MicrowaveModel_Notifications_AttributeValueChangedNotification notification
* Called by your code when notification event occurs
* 
********************************************************************/
void u_MicrowaveModel_Notifications_AttributeValueChangedNotification_send (
    int32 counter,
    const xmlChar *timeStamp,
    const xmlChar *objectIdRef,
    const xmlChar *attributeName,
    const xmlChar *newValue)
{
    agt_not_msg_t *notif;
    val_value_t *parmval;
    status_t res = NO_ERR;


    if (LOGDEBUG) {
        log_debug("\nGenerating <AttributeValueChangedNotification> notification");
    }
    
    notif = agt_not_new_notification(AttributeValueChangedNotification_obj);
    if (notif == NULL) {
        log_error("\nError: malloc failed, cannot send "
        "<AttributeValueChangedNotification> notification");
        return;
    }
    
    /* add counter to payload */
    parmval = agt_make_int_leaf(
        AttributeValueChangedNotification_obj,
        y_MicrowaveModel_Notifications_N_counter,
        counter,
        &res);
    if (parmval == NULL) {
        log_error(
            "\nError: make leaf failed (%s), cannot send "
            "<AttributeValueChangedNotification> notification",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }
    
    /* add timeStamp to payload */
    parmval = agt_make_leaf(
        AttributeValueChangedNotification_obj,
        y_MicrowaveModel_Notifications_N_timeStamp,
        timeStamp,
        &res);
    if (parmval == NULL) {
        log_error(
            "\nError: make leaf failed (%s), cannot send "
            "<AttributeValueChangedNotification> notification",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }
    
    /* add objectIdRef to payload */
    parmval = agt_make_leaf(
        AttributeValueChangedNotification_obj,
        y_MicrowaveModel_Notifications_N_objectIdRef,
        objectIdRef,
        &res);
    if (parmval == NULL) {
        log_error(
            "\nError: make leaf failed (%s), cannot send "
            "<AttributeValueChangedNotification> notification",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }
    
    /* add attributeName to payload */
    parmval = agt_make_leaf(
        AttributeValueChangedNotification_obj,
        y_MicrowaveModel_Notifications_N_attributeName,
        attributeName,
        &res);
    if (parmval == NULL) {
        log_error(
            "\nError: make leaf failed (%s), cannot send "
            "<AttributeValueChangedNotification> notification",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }
    
    /* add newValue to payload */
    parmval = agt_make_leaf(
        AttributeValueChangedNotification_obj,
        y_MicrowaveModel_Notifications_N_newValue,
        newValue,
        &res);
    if (parmval == NULL) {
        log_error(
            "\nError: make leaf failed (%s), cannot send "
            "<AttributeValueChangedNotification> notification",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }
    
    agt_not_queue_notification(notif);
    
} /* u_MicrowaveModel_Notifications_AttributeValueChangedNotification_send */


/********************************************************************
* FUNCTION u_MicrowaveModel_Notifications_ProblemNotification_send
* 
* Send a u_MicrowaveModel_Notifications_ProblemNotification notification
* Called by your code when notification event occurs
* 
********************************************************************/
void u_MicrowaveModel_Notifications_ProblemNotification_send (
    int32 counter,
    const xmlChar *timeStamp,
    const xmlChar *objectIdRef,
    const xmlChar *problem,
    const xmlChar *severity)
{
    agt_not_msg_t *notif;
    val_value_t *parmval;
    status_t res = NO_ERR;


    if (LOGDEBUG) {
        log_debug("\nGenerating <ProblemNotification> notification");
    }
    
    notif = agt_not_new_notification(ProblemNotification_obj);
    if (notif == NULL) {
        log_error("\nError: malloc failed, cannot send "
        "<ProblemNotification> notification");
        return;
    }
    
    /* add counter to payload */
    parmval = agt_make_int_leaf(
        ProblemNotification_obj,
        y_MicrowaveModel_Notifications_N_counter,
        counter,
        &res);
    if (parmval == NULL) {
        log_error(
            "\nError: make leaf failed (%s), cannot send "
            "<ProblemNotification> notification",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }
    
    /* add timeStamp to payload */
    parmval = agt_make_leaf(
        ProblemNotification_obj,
        y_MicrowaveModel_Notifications_N_timeStamp,
        timeStamp,
        &res);
    if (parmval == NULL) {
        log_error(
            "\nError: make leaf failed (%s), cannot send "
            "<ProblemNotification> notification",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }
    
    /* add objectIdRef to payload */
    parmval = agt_make_leaf(
        ProblemNotification_obj,
        y_MicrowaveModel_Notifications_N_objectIdRef,
        objectIdRef,
        &res);
    if (parmval == NULL) {
        log_error(
            "\nError: make leaf failed (%s), cannot send "
            "<ProblemNotification> notification",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }
    
    /* add problem to payload */
    parmval = agt_make_leaf(
        ProblemNotification_obj,
        y_MicrowaveModel_Notifications_N_problem,
        problem,
        &res);
    if (parmval == NULL) {
        log_error(
            "\nError: make leaf failed (%s), cannot send "
            "<ProblemNotification> notification",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }
    
    /* add severity to payload */
    parmval = agt_make_leaf(
        ProblemNotification_obj,
        y_MicrowaveModel_Notifications_N_severity,
        severity,
        &res);
    if (parmval == NULL) {
        log_error(
            "\nError: make leaf failed (%s), cannot send "
            "<ProblemNotification> notification",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }
    
    agt_not_queue_notification(notif);
    
} /* u_MicrowaveModel_Notifications_ProblemNotification_send */

/********************************************************************
* FUNCTION u_MicrowaveModel_Notifications_init
* 
* initialize the MicrowaveModel-Notifications server instrumentation library
* 
* INPUTS:
*    modname == requested module name
*    revision == requested version (NULL for any)
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_Notifications_init (
    const xmlChar *modname,
    const xmlChar *revision)
{
    status_t res = NO_ERR;
    ncx_module_t *MicrowaveModel_Notifications_mod = NULL;
    MicrowaveModel_Notifications_mod = ncx_find_module(
        y_MicrowaveModel_Notifications_M_MicrowaveModel_Notifications,
        y_MicrowaveModel_Notifications_R_MicrowaveModel_Notifications);
    if (MicrowaveModel_Notifications_mod == NULL) {
        return ERR_NCX_OPERATION_FAILED;
    }
    ObjectCreationNotification_obj = ncx_find_object(
        MicrowaveModel_Notifications_mod,
        y_MicrowaveModel_Notifications_N_ObjectCreationNotification);
    if (MicrowaveModel_Notifications_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    ObjectDeletionNotification_obj = ncx_find_object(
        MicrowaveModel_Notifications_mod,
        y_MicrowaveModel_Notifications_N_ObjectDeletionNotification);
    if (MicrowaveModel_Notifications_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    AttributeValueChangedNotification_obj = ncx_find_object(
        MicrowaveModel_Notifications_mod,
        y_MicrowaveModel_Notifications_N_AttributeValueChangedNotification);
    if (MicrowaveModel_Notifications_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    ProblemNotification_obj = ncx_find_object(
        MicrowaveModel_Notifications_mod,
        y_MicrowaveModel_Notifications_N_ProblemNotification);
    if (MicrowaveModel_Notifications_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    /* put your module initialization code here */
    
    return res;
} /* u_MicrowaveModel_Notifications_init */

static int sendCustomNotification(const xmlChar* dateAndTime, int alarmId, int ifIndex, int state, int severity)
{
	switch (alarmId)
	{
		case 0: //define your own alarm IDs and use them here
		{
			char ifIndexStr[64];
			sprintf(ifIndexStr, LTP_MWPS_PREFIX"%lu", ifIndex);

			u_MicrowaveModel_Notifications_AttributeValueChangedNotification_send(g_attr_counter++,
					dateAndTime,
					ifIndexStr,
					"transmitterIsOn",
					(state == 1) ? "false" : "true");
			u_MicrowaveModel_Notifications_ProblemNotification_send(g_problems_counter++,
					dateAndTime,
					ifIndexStr, //layer protocol here
					"transmitterIsTurnedOff", //problemName here
					(state == 1) ? "warning" : "non-alarmed");
			break;
		}
		default:
			YUMA_ASSERT(TRUE, NOP, "AlarmId=%d having severity=%d and state=%d for ifIndex=%lu is not yet handled, not sending any notification",
					alarmId, severity, state, ifIndex);
	}

	return 1;
}

static int handleSnmpTrap(int op, netsnmp_session* session, int reqid, netsnmp_pdu* response, void *magic)
{
	struct variable_list *vars;

	if (op == NETSNMP_CALLBACK_OP_RECEIVED_MESSAGE)
	{
		/* drop problem packets */
		YUMA_ASSERT(session->s_snmp_errno, return 1, "Received SNMP packet with errors!");

		if (response->command == SNMP_MSG_TRAP2) /* TRAP V2 */
		{
		    unsigned long int alarmId = 0, ifIndex = 0, severity = 0, state = 0;

			/*----------------------------------------------
			 * Insert here the code to manage SNMP trap
			 * need to extract the alarmId, ifIndex (actually the layerProtocol), severity and state of the alarm (raised/cleared)
			 *---------------------------------------------*/

			xmlChar dateAndTime[256];

			/*
			 * Create dateAndTime according to ONF specifications
			 */
			time_t t = time(NULL);
			struct tm tm = *localtime(&t);
			struct timeval tv;

			gettimeofday(&tv, NULL);
			int millisec;
			millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
			if (millisec>=1000)
			{ // Allow for rounding up to nearest second
				millisec -=1000;
				tv.tv_sec++;
				millisec /= 100;
			}

			sprintf(dateAndTime, "%04d%02d%02d%02d%02d%02d.%01dZ", tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec,
					millisec/100);

			int ret = sendCustomNotification(dateAndTime, alarmId, ifIndex, state, severity);
			YUMA_ASSERT(ret == FALSE, return FALSE, "Failed to sendCustomNotification for alarmId=%d", alarmId);
		}
	}
	else if (op == NETSNMP_CALLBACK_OP_TIMED_OUT)
	{
		YUMA_ASSERT(TRUE, NOP, "Timeout: This shouldn't happen!\n");
	}
	return 1;
}

static status_t waitForSnmpTrap()
{
	int ret = 0, done, maxNumOfFD = transport->sock;

	FD_ZERO(&read_fd_set);

	YUMA_ASSERT(TRUE, NOP, "Thread listening for SNMP Traps...");

	//This thread will block in a loop, waiting for SNMP Traps

	while (TRUE)
	{
		done = FALSE;
		while (!done) {
			//Set the file descriptor to listen for modifications to the socket associated with the SNMP trap
			FD_SET(transport->sock, &read_fd_set);

			//Block for 5 seconds waiting for something on the socket
			timeout.tv_sec = 5;
			timeout.tv_usec = 0;

			/* Block until input arrives on one or more active sockets.
			 * or the timer expires
			 */
			ret = select(maxNumOfFD + 1, //the max number of the FD to listen to
						 &read_fd_set,
						 NULL,
						 NULL,
						 &timeout);
			if (ret > 0) { //the FD was ready for reading
				done = TRUE;
			} else if (ret < 0) {
				if (!(errno == EINTR || errno==EAGAIN)) {
					done = TRUE;
				}
			} else if (ret == 0) {
				/* should only happen if a timeout occurred */
				if (agt_shutdown_requested()) {
					done = TRUE;
				} else {
					/* !! put all polling callbacks here for now !! */
					agt_ses_check_timeouts();
					agt_timer_handler();
				}
			} else {
				/* normal return with some bytes */
				done = TRUE;
			}
		}

		//Read the actual data from the socket, and call the associated handle of the SNMP session
		snmp_read(&read_fd_set);
	}

	YUMA_ASSERT(TRUE, NOP, "Finished the SNMP trap listen loop, we should not be here!");

	snmp_close(session);
	netsnmp_transport_free(transport);

	return NO_ERR;
}

static status_t addSnmpTrapSession()
{
	init_snmp("mdtrapd");
	init_agent("mdtrapd");

	transport = netsnmp_tdomain_transport("udp:162", 1, "udp");
    YUMA_ASSERT(transport == NULL, return ERR_INTERNAL_VAL, "########### SNMP Transport could not be opened! Are you sure you are running as root ? ##############");

	snmp_sess_init(session);
	session->peername = SNMP_DEFAULT_PEERNAME;  /* Original code had NULL here */
	session->version = SNMP_VERSION_2c;
	session->community = "public";
	session->community_len = strlen(session->community);
	session->retries = SNMP_DEFAULT_RETRIES;
	session->timeout = SNMP_DEFAULT_TIMEOUT;
	session->callback = handleSnmpTrap;
	session->callback_magic = (void *) transport;
	session->authenticator = NULL;
	sess.isAuthoritative = SNMP_SESS_UNKNOWNAUTH;

	rc = snmp_add(session, transport, NULL, NULL);
	YUMA_ASSERT(rc == NULL, return ERR_INTERNAL_VAL, "COULD NOT ADD SNMP SESSION!");

	YUMA_ASSERT(TRUE, NOP, "SNMP Trap session added and Transport Socket=%d", transport->sock);

	return NO_ERR;
}

/********************************************************************
* FUNCTION u_MicrowaveModel_Notifications_init2
* 
* SIL init phase 2: non-config data structures
* Called after running config is loaded
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_Notifications_init2 (void)
{
    status_t res = NO_ERR;

    pthread_t wait_for_trap_thread;

    res = addSnmpTrapSession();
    YUMA_ASSERT(res != NO_ERR, return ERR_INTERNAL_VAL, "Could not addSnmpTrapSession!");

    if(pthread_create(&wait_for_trap_thread, NULL, waitForSnmpTrap, NULL))
	{
		YUMA_ASSERT(TRUE, return ERR_INTERNAL_VAL, "Could not create thread that listens to SNMP Traps!");
	}

    return NO_ERR;
} /* u_MicrowaveModel_Notifications_init2 */

/********************************************************************
* FUNCTION u_MicrowaveModel_Notifications_cleanup
*    cleanup the server instrumentation library
* 
********************************************************************/
void u_MicrowaveModel_Notifications_cleanup (void)
{
    /* put your cleanup code here */
    
} /* u_MicrowaveModel_Notifications_cleanup */

/* END u_MicrowaveModel_Notifications.c */
